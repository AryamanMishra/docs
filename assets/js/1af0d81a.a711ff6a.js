"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5182],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>m});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),p=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(r),m=a,f=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return r?n.createElement(f,i(i({ref:t},c),{},{components:r})):n.createElement(f,i({ref:t},c))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=r[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},3907:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=r(7462),a=(r(7294),r(3905));const o={sidebar_position:1},i="Custom extractors",s={unversionedId:"integrations/airflow/extractor",id:"integrations/airflow/extractor",title:"Custom extractors",description:"OpenLineage integration works by detecting which Airflow operators your dag is using, and extracting lineage",source:"@site/docs/integrations/airflow/extractor.md",sourceDirName:"integrations/airflow",slug:"/integrations/airflow/extractor",permalink:"/docs/integrations/airflow/extractor",draft:!1,editUrl:"https://github.com/OpenLineage/docs/tree/main/docs/integrations/airflow/extractor.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Apache Airflow",permalink:"/docs/integrations/airflow/"},next:{title:"Lineage in custom operators",permalink:"/docs/integrations/airflow/operator"}},l={},p=[{value:"Interface",id:"interface",level:2},{value:"Registering custom extractor",id:"registering-custom-extractor",level:2},{value:"Debugging issues",id:"debugging-issues",level:2}],c={toc:p};function d(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"custom-extractors"},"Custom extractors"),(0,a.kt)("p",null,"OpenLineage integration works by detecting which Airflow operators your dag is using, and extracting lineage\ndata from them using extractors. "),(0,a.kt)("p",null,"However, there are hundreds of operators in Airflow. In addition, many people and teams write their own operators to\nautomate repeatable work - like using the same code from ",(0,a.kt)("inlineCode",{parentName:"p"},"PythonOperator")," everywhere."),(0,a.kt)("p",null,"So, most of those operators aren't directly supported in OpenLineage out of the box.\nTo handle this situation, OpenLineage allows you to provide custom extractors for any operators."),(0,a.kt)("h2",{id:"interface"},"Interface"),(0,a.kt)("p",null,"Custom extractors have to derive from ",(0,a.kt)("inlineCode",{parentName:"p"},"BaseExtractor"),"."),(0,a.kt)("p",null,"Extractors have three methods to implement: ",(0,a.kt)("inlineCode",{parentName:"p"},"extract"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"extract_on_complete")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"get_operator_classnames"),".\nThe last one is a classmethod that is used to provide list of operators that your extractor can get lineage from."),(0,a.kt)("p",null,"For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"@classmethod\ndef get_operator_classnames(cls) -> List[str]:\n  return ['PostgresOperator']\n")),(0,a.kt)("p",null,"If the name of the operator matches one of the names on the list, the extractor will be instantiated - with operator\nprovided in the extractor's ",(0,a.kt)("inlineCode",{parentName:"p"},"self.operator")," property - and both ",(0,a.kt)("inlineCode",{parentName:"p"},"extract")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"extract_on_complete")," methods will be called.\nThey are used to provide actual information data. The difference is that ",(0,a.kt)("inlineCode",{parentName:"p"},"extract")," is called before operator's ",(0,a.kt)("inlineCode",{parentName:"p"},"execute"),"\nmethod, while ",(0,a.kt)("inlineCode",{parentName:"p"},"extract_on_complete")," is called after. This can be used to extract any additional information that the operator\nsets on it's own properties. Good example is ",(0,a.kt)("inlineCode",{parentName:"p"},"SnowflakeOperator")," that sets ",(0,a.kt)("inlineCode",{parentName:"p"},"query_ids")," after execution."),(0,a.kt)("p",null,"Both methods return ",(0,a.kt)("inlineCode",{parentName:"p"},"TaskMetadata")," structure:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"@attr.s\nclass TaskMetadata:\n    name: str = attr.ib()  # deprecated\n    inputs: List[Dataset] = attr.ib(factory=list)\n    outputs: List[Dataset] = attr.ib(factory=list)\n    run_facets: Dict[str, BaseFacet] = attr.ib(factory=dict)\n    job_facets: Dict[str, BaseFacet] = attr.ib(factory=dict)\n")),(0,a.kt)("p",null,"Inputs and outputs are lists of plain ",(0,a.kt)("a",{parentName:"p",href:"/docs/client/python"},"OpenLineage datasets")," "),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"run_facets")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"job_facets")," are dictionaries of optional ",(0,a.kt)("a",{parentName:"p",href:"/docs/client/python"},"JobFacets")," and ",(0,a.kt)("a",{parentName:"p",href:"/docs/client/python"},"RunFacets")," that would be attached to the job - for example,\nyou might want to attach ",(0,a.kt)("inlineCode",{parentName:"p"},"SqlJobFacet")," if your operator is executing SQL."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Add spec description that would be used in those links.")),(0,a.kt)("h2",{id:"registering-custom-extractor"},"Registering custom extractor"),(0,a.kt)("p",null,"OpenLineage integration does not know that you've provided an extractor unless you'll register it."),(0,a.kt)("p",null,"The way to do that is to add them to ",(0,a.kt)("inlineCode",{parentName:"p"},"OPENLINEAGE_EXTRACTORS")," environment variable."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"OPENLINEAGE_EXTRACTORS=full.path.to.ExtractorClass\n")),(0,a.kt)("p",null,"If you have multiple custom extractors, separate the paths with comma ",(0,a.kt)("inlineCode",{parentName:"p"},"(;)")," "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"OPENLINEAGE_EXTRACTORS=full.path.to.ExtractorClass;full.path.to.AnotherExtractorClass\n")),(0,a.kt)("p",null,"Optionally, you can separate them with whitespace. It's useful if you're providing them as part of some YAML file."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"OPENLINEAGE_EXTRACTORS: >-\n  full.path.to.FirstExtractor;\n  full.path.to.SecondExtractor\n")),(0,a.kt)("h2",{id:"debugging-issues"},"Debugging issues"),(0,a.kt)("p",null,"There are two common problems associated with custom extractors.\nFirst, is wrong path provided to ",(0,a.kt)("inlineCode",{parentName:"p"},"OPENLINEAGE_EXTRACTORS"),".\nThe path needs to be exactly the same as one you'd use from your code. If the path is wrong, the extractor won't get imported\nand OpenLineage events won't be emitted."),(0,a.kt)("p",null,"Second one, and maybe more insidious, are imports from Airflow. Due to the fact that OpenLineage code gets instantiated when\nAirflow worker itself starts, any import from Airflow can be unnoticeably cyclical. This causes OpenLineage extraction to fail."),(0,a.kt)("p",null,"To avoid this issue, import from Airflow only locally - in ",(0,a.kt)("inlineCode",{parentName:"p"},"extract")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"extract_on_complete")," methods. If you need imports for\ntype checking, guard them behind ",(0,a.kt)("inlineCode",{parentName:"p"},"typing.TYPE_CHECKING"),"."))}d.isMDXComponent=!0}}]);