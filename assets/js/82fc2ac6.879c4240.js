"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[246],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>f});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(r),f=a,m=d["".concat(l,".").concat(f)]||d[f]||u[f]||s;return r?n.createElement(m,o(o({ref:t},p),{},{components:r})):n.createElement(m,o({ref:t},p))}));function f(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=r.length,o=new Array(s);o[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var c=2;c<s;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},9887:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var n=r(7462),a=(r(7294),r(3905));const s={sidebar_position:5},o="SQL parser",i={unversionedId:"integrations/sql",id:"integrations/sql",title:"SQL parser",description:"SQL is the most widely used data processing language and for a lot of use cases, getting lineage from SQL-based tasks is solving majority of the problem.",source:"@site/docs/integrations/sql.md",sourceDirName:"integrations",slug:"/integrations/sql",permalink:"/docs/integrations/sql",draft:!1,editUrl:"https://github.com/OpenLineage/docs/tree/main/docs/integrations/sql.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Writing our own integration",permalink:"/docs/integrations/libraries"},next:{title:"About These Examples",permalink:"/docs/guides/about"}},l={},c=[{value:"Interface",id:"interface",level:3},{value:"Default databases and schemas",id:"default-databases-and-schemas",level:3}],p={toc:c};function u(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"sql-parser"},"SQL parser"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"SQL")," is the most widely used data processing language and for a lot of use cases, getting lineage from SQL-based tasks is solving majority of the problem.\nFor this reason, we've created SQL parser that allows you to get lineage directly by processing SQL query."),(0,a.kt)("p",null,"Our SQL parser is based on excellent ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sqlparser-rs/sqlparser-rs"},"sqlparser-rs")," library."),(0,a.kt)("h3",{id:"interface"},"Interface"),(0,a.kt)("p",null,"SQL parser interface expressed in pseudo-python."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'class DbTableMeta:\n    database: Optional[str]\n    schema: Optional[str]\n    name: str\n\n\nclass SqlMeta:\n    in_tables: List[DbTableMeta]\n    out_tables: List[DbTableMeta]\n\ndef parse(\n    sql: Union[List[str], str],\n    # Setting dialect allows you to enable some dialect-specific processing \n    # like using backticks "`" as delimiters in BigQuery tables.\n    dialect: Optional[str] = None,   \n    # Setting this will make parser use this schema for every table that\n    # does not specify schema. \n    default_schema: Optional[str] = None\n) -> Optional[SqlMeta] \n')),(0,a.kt)("h3",{id:"default-databases-and-schemas"},"Default databases and schemas"),(0,a.kt)("p",null,"SQL processing engines and databases sometimes rely on some ",(0,a.kt)("em",{parentName:"p"},"implicit")," information. For example, they often allow you to set current database or schema, instead of forcing\nyou to specify fully-qualified table name every time you're refering to it."),(0,a.kt)("p",null,"For this reason, bare SQL parser might be insufficient to fully understand which tables the query refers to.\nWe recommend to process the data that you acquired from SQL parser to take that into account."))}u.isMDXComponent=!0}}]);