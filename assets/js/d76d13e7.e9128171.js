"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2597],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),f=o,d=m["".concat(l,".").concat(f)]||m[f]||u[f]||r;return n?a.createElement(d,i(i({ref:t},c),{},{components:n})):a.createElement(d,i({ref:t},c))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8237:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:3},i="Exposing lineage in Airflow operators",s={unversionedId:"integrations/airflow/operator",id:"integrations/airflow/operator",title:"Exposing lineage in Airflow operators",description:"Since: 0.18.0",source:"@site/docs/integrations/airflow/operator.md",sourceDirName:"integrations/airflow",slug:"/integrations/airflow/operator",permalink:"/docs/integrations/airflow/operator",draft:!1,editUrl:"https://github.com/OpenLineage/docs/tree/main/docs/integrations/airflow/operator.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Using the Airflow integration",permalink:"/docs/integrations/airflow/usage"},next:{title:"Manually annotated lineage",permalink:"/docs/integrations/airflow/manual"}},l={},p=[{value:"Scope",id:"scope",level:2},{value:"Context",id:"context",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Relevant facets",id:"relevant-facets",level:3},{value:"Dataset facets",id:"dataset-facets",level:4},{value:"Output facets",id:"output-facets",level:4},{value:"Run facets",id:"run-facets",level:4},{value:"All facets",id:"all-facets",level:4}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"exposing-lineage-in-airflow-operators"},"Exposing lineage in Airflow operators"),(0,o.kt)("p",null,"Since: 0.18.0"),(0,o.kt)("h2",{id:"scope"},"Scope"),(0,o.kt)("p",null,"Lineage extraction logic should be as close as possible to the operator logic. For Airflow's included operators, this logic would ideally live in the Airflow repository; for external providers, it would live in their own repository. This makes lineage extraction more stable, as it lives with the operators."),(0,o.kt)("p",null,"Previously the OpenLineage library required one ",(0,o.kt)("inlineCode",{parentName:"p"},"Extractor")," for each supported ",(0,o.kt)("inlineCode",{parentName:"p"},"Operator")," which is brittle and can break when operator internals change.\nIt's too cumbersome for people who own operators, and want to add the default implementation of OpenLineage for their operators for external users.\nThis is still an option when you can't modify the operator itself: See ",(0,o.kt)("a",{parentName:"p",href:"/docs/integrations/airflow/extractors/custom-extractors"},"add custom extractors"),". "),(0,o.kt)("p",null,"Each operator is responsible for describing lineage per the spec below, but the actual lineage events are still being sent by the OpenLineage library in the TaskInstanceListener."),(0,o.kt)("h2",{id:"context"},"Context"),(0,o.kt)("p",null,"OpenLineage collects the following information regarding the Datasets being read and written by a task:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Dataset name and namespace ","[required]"," - the format for naming is outlined in the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/OpenLineage/OpenLineage/blob/main/spec/Naming.md#datasets"},"naming specification"),"."),(0,o.kt)("li",{parentName:"ul"},"Dataset schema ","[optional]"," - The column names and types, if known. Complex types, like structs and arrays are supported"),(0,o.kt)("li",{parentName:"ul"},"Query id ","[optional]"," - for systems that expose an identifier, the ID of the query. This is a Run facet, not a Dataset facet, but it is often exposed by the Data Source\u2019s proprietary API. For example, operators for Bigquery, Redshift, and Snowflake should all allow this."),(0,o.kt)("li",{parentName:"ul"},"Input/output statistics ","[optional]"," - The number of records and/or bytes consumed or written.\nExample in the BigQuery extractor:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/OpenLineage/OpenLineage/blob/504f99e2f4dabd4f73a194dc5258ac81dae95d96/integration/common/openlineage/common/provider/bigquery.py#L111-L116"},"Creating the relevant facet"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/get"},"BigQuery API"),". ",(0,o.kt)("a",{parentName:"li",href:"https://cloud.google.com/bigquery/docs/query-plan-explanation#query_plan_information"},"plan info")))),(0,o.kt)("li",{parentName:"ul"},"Data quality metrics ","[optional]"," - Metrics associated with quality checks performed on the dataset. For example implemented by the Great Expectations integration.")),(0,o.kt)("p",null,"Operators that intend to share information about the datasets being read and written should also expose either some of the above-mentioned information or some minimal information necessary to retrieve that information."),(0,o.kt)("p",null,"The absolute minimum information the operators need to share is "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The type of datasource being accessed (e.g., BigQuery, Snowflake, PostgreSQL)"),(0,o.kt)("li",{parentName:"ol"},"The host or authority - this is often where the data is being hosted, such as the postgres server URL, the Hive metastore URL, the GCS bucket, the Snowflake account identifier..."),(0,o.kt)("li",{parentName:"ol"},"The fully qualified data path - this may be a table name, such as public.MyDataset.MyTable or a path in a bucket, e.g., path/to/my/data as defined in ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/OpenLineage/OpenLineage/blob/main/spec/Naming.md"},"the OpenLineage spec for consistency across operators"),".")),(0,o.kt)("p",null,"This information needs to be shared for each dataset being read and written in a task. The naming spec in the OpenLineage repository uses the above information to construct a Dataset namespace and name; together they uniquely identify the dataset. "),(0,o.kt)("p",null,'For metadata about the execution of the task, a queryId or executionId should be exposed for data sources that support them. With that identifier, we can query the data source about the execution and gather statistics, such as "d" number of records read/written.'),(0,o.kt)("p",null,"An operator can also includes data quality assertions. The ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/OpenLineage/OpenLineage/blob/main/spec/facets/DataQualityAssertionsDatasetFacet.json"},"DataQuality facet specification can be found in here"),"."),(0,o.kt)("h2",{id:"implementation"},"Implementation"),(0,o.kt)("p",null,"Each ",(0,o.kt)("inlineCode",{parentName:"p"},"Operator")," implements the following methods returning the structure defined below:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"get_openlineage_facets_on_start()"),(0,o.kt)("li",{parentName:"ul"},"get_openlineage_facets_on_complete(ti)\nFacets are the JSON facets defined in the OpenLineage specification")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"OperatorLineage:\n    runFacets: dict{}\n    jobFacets: dict{}\n    inputs: [InputDataset]\n    outputs: [OutputDataset]\n \nInputDataset:\n    namespace: string\n    name: string\n    facets: dict{}\n    inputFacets: dict{}\n\nOutputDataset:\n    namespace: string\n    name: string\n    facets: dict{}\n    outputFacets: dict{}\n")),(0,o.kt)("p",null,"(all facets are optional)"),(0,o.kt)("p",null,"When the task starts/completes, the OpenLineage TaskInstanceListener uses the selected method if available to construct lineage events. The order of selection of the method is as follows: if there is no extractor defined (based on get",(0,o.kt)("em",{parentName:"p"},"operator_classnames) it will fall back to DefaultExtractor. DefaultExtractor uses get_openlineage_facets"),"* methods. If the get_openlineage_facets_on_complete(ti) is not available it falls back to get_openlineage_facets_on_start()."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n "runFacets": {\n   "errorMessage": {\n     "message": "could not connect to foo",\n     "language": "python"\n   }\n },\n "jobFacets": {\n    "sql": {\n      "query": "CREATE TABLE FOO AS SELECT * FROM BAR"\n   }\n },\n "inputs": [{\n   "namespace": "postgres://example",\n   "name": "workshop.public.wealth",\n   "facets": { \n     "schema": {\n       "fields": [{ \n         "name": "foo"\n         "type": "char"\n         "description": "my first field"\n         }, \n         ]\n      }\n   },\n   "inputFacets": {\n      "dataQualityMetrics": {\n         "rowCount" : 1345\n      }\n   }\n }], \n "outputs": [{\n   "namespace": "postgres://example",\n   "name": "workshop.public.death",\n   "facets": {\n      "schema": {\n        "fields": [{ \n           "name": "foo"\n           "type": "char"\n           "description": "my first field"\n        }, \n        ]\n      }\n   },\n   "outputFacets": {\n      "outputStatistics": {\n         "rowCount": 10,\n         "size": 1000\n      }\n   }\n  }, {\n   "namespace": "postgres://example",\n   "name": "workshop.public.taxes"\n   "facets": {\n      "schema": {\n        "fields": [{ \n           "name": "foo"\n           "type": "char"\n           "description": "my first field"\n        }, \n        ]\n      }\n   },\n   "outputFacets": {\n      "outputStatistics": {\n         "rowCount": 10,\n         "size": 1000\n      }\n   }\n }], \n}\n')),(0,o.kt)("h3",{id:"relevant-facets"},"Relevant facets"),(0,o.kt)("p",null,"Here are some relevant examples of facets that can be added.\nPlease consult ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/OpenLineage/OpenLineage/blob/main/spec/OpenLineage.md#standard-facets"},"the spec")," for the full list.\nCustom facets can also be added, using a common facet name prefix."),(0,o.kt)("h4",{id:"dataset-facets"},"Dataset facets"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/OpenLineage/OpenLineage/blob/main/spec/facets/SchemaDatasetFacet.json"},"Schema")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"schema: {\n    fields: [{ \n        Name: \u201d\u201d\n        Type: \u201d\u201d\n        Description: \u201d\u201d\n}, \u2026]\n}\n")),(0,o.kt)("h4",{id:"output-facets"},"Output facets"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/OpenLineage/OpenLineage/blob/main/spec/facets/OutputStatisticsOutputDatasetFacet.json"},"OutputStatistics")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"outputStatistics: {\n    rowCount: 10\n    Size: 1000\n}\n")),(0,o.kt)("h4",{id:"run-facets"},"Run facets"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/OpenLineage/OpenLineage/blob/main/spec/facets/ErrorMessageRunFacet.json"},"ErrorMessage")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"errorMessage: {\n    Message: \u201d\u201d\n    programmingLanguage: \u201d\u201d\n    stackTrace: \u201d\u201d\n}\n")),(0,o.kt)("h4",{id:"all-facets"},"All facets"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/OpenLineage/OpenLineage/tree/main/spec/facets"},"Facets")))}u.isMDXComponent=!0}}]);